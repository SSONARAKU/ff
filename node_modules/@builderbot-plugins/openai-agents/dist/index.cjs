'use strict';

/**
 *
 * @param inputText
 * @returns
 */
const cleanText = (inputText) => {
    return inputText.replace('"', "");
};
/**
 *
 * @param text
 * @returns
 */
const determineAgent = (text) => {
    try {
        text = text.replaceAll("\n", " ");
        const match = /\[(.*?)\]:\s*(.*?)(?=\s*\[|$)/.exec(text);
        if (match.length < 3) {
            throw new Error(`Could not parse LLM output: ${text}`);
        }
        const tool = match[1].trim().replaceAll(":", "").replaceAll('[', "").replaceAll(']', "");
        const answer = match[2].trim().replaceAll("EmployeeAnswer", "").replaceAll(':', "");
        if (!answer) {
            throw new Error(`Could not parse LLM output: ${text}`);
        }
        return {
            tool,
            answer,
            log: cleanText(text),
        };
    }
    catch (e) {
        return undefined;
    }
};

const PROMPTS = {
    FORMAT_INSTRUCTIONS: `Actúa como un gerente de negocio el cual analizará la siguiente lista de empleados o agentes: 
  [{employees}] 
  
  Selecciona el empleado o agente cuya descripción lo haga el más adecuado para responder la pregunta del usuario, 
  Siempre debes literalmente continuar la frase en primera persona con el nombre del empleado encerrado en corchetes []: 
  '[NOMBRE_DEL_EMPLEADO]: respuesta' 

  Si ninguno de los empleados o agentes anteriores es adecuado o si la pregunta del usuario no está relacionada con nuestro negocio, 
  responde literalmente: 
  '[NOT_EMPLOYEE]: not employee'`
};

/**
 *
 * @param {*} employees
 * @returns
 */
const buildPromptEmployee = (employees) => {
    if (!Array.isArray(employees)) {
        throw new Error("Debes ser un array de agentes");
    }
    employees.reduce((pre, ccu) => {
        if (pre.includes(ccu.name)) {
            throw new Error(`Nombre de agente debe ser unico: ${ccu.name} repetido`);
        }
        return [...pre, ccu.name];
    }, []);
    const agentsDescriptions = employees.map((agent) => ({
        [agent.name]: agent.description, name: agent.name,
    }));
    const promptOutput = PROMPTS.FORMAT_INSTRUCTIONS.replace("[{employees}]", JSON.stringify(agentsDescriptions));
    return promptOutput;
};

class OpenAiClass {
    constructor(openAiOptions = { model: 'gpt-3.5-turbo', temperature: 0, apiKey: '' }) {
        this.openAiOptions = openAiOptions;
        this.requestOptions = {};
        /**
         *
         * @returns
         */
        this.buildHeader = () => {
            const headers = new Headers();
            headers.append('Content-Type', 'application/json');
            headers.append('Authorization', `Bearer ${this.openAiOptions.apiKey}`);
            return headers;
        };
        /**
         *
         * @param {*} input
         */
        this.sendEmbedding = async (input, model = 'text-embedding-ada-002') => {
            const raw = JSON.stringify({
                input,
                model,
            });
            this.requestOptions.body = raw;
            const response = await fetch('https://api.openai.com/v1/embeddings', this.requestOptions);
            return response.json();
        };
        /**
         *
         * @param {*} messages
         * @returns
         */
        this.sendChat = async (messages = []) => {
            const raw = JSON.stringify({
                model: this.openAiOptions.model,
                temperature: this.openAiOptions.temperature,
                messages,
            });
            this.requestOptions.body = raw;
            const response = await fetch('https://api.openai.com/v1/chat/completions', this.requestOptions);
            return response.json();
        };
        /**
         *
         * @param {*} prompt
         * @returns
         */
        this.sendCompletions = async (prompt = undefined) => {
            const raw = JSON.stringify({
                model: this.openAiOptions.model,
                temperature: this.openAiOptions.temperature,
                prompt
            });
            this.requestOptions.body = raw;
            const response = await fetch('https://api.openai.com/v1/completions', this.requestOptions);
            return response.json();
        };
        if (!this.openAiOptions?.apiKey) {
            throw new Error('apiKey no pude ser vacio');
        }
        this.requestOptions = {
            method: 'POST',
            headers: this.buildHeader(),
            body: null,
            redirect: 'follow',
        };
    }
}

class EmployeesClass extends OpenAiClass {
    constructor(_settings) {
        super(_settings);
        this.listEmployees = [];
        /**
         *
         * @param {*} employees [] array
         */
        this.employees = (employees = []) => this.listEmployees = employees;
        /**
         *
         * @param {*} employeeName
         * @returns
         */
        this.getAgent = (employeeName) => {
            const indexEmployee = this.listEmployees.findIndex((emp) => emp.name === employeeName);
            return this.listEmployees[indexEmployee];
        };
        /**
         *
         */
        this.determine = async (text) => {
            try {
                const messages = [
                    {
                        role: "system",
                        content: buildPromptEmployee(this.listEmployees),
                    },
                    {
                        role: "user",
                        content: text,
                    },
                ];
                const llmDetermineEmployee = await this.sendChat(messages);
                if (llmDetermineEmployee?.error) {
                    throw new Error(llmDetermineEmployee?.error?.message);
                }
                const bestChoise = determineAgent(llmDetermineEmployee.choices[0].message.content);
                const employee = this.getAgent(`${bestChoise?.tool}`);
                return { employee, answer: bestChoise.answer };
            }
            catch (err) {
                console.log({ err });
                return undefined;
            }
        };
        /**
         * @param {*} employee
         * @param {*} ctxFn
         */
        this.gotoFlow = (employee, ctxFn) => {
            const flow = employee.flow;
            ctxFn.gotoFlow(flow);
        };
    }
}

/**
 *
 * @param  {Object}  settings
 * @param  {String}  settings.model    model gpt-3.5-turbo
 * @param  {Array}   settings.temperature  0
 * @param  {Integer} settings.apiKey     your api key opena
 * @returns
 */
const init = (settings) => {
    return new EmployeesClass(settings);
};

exports.EmployeesClass = EmployeesClass;
exports.init = init;
